#include "kl.h"

bool KL_active = false;
HHOOK KL_handle;

// bitmask: MOD_ALT/CONTROL/SHIFT/WIN, KLM_L3,KLM_L5
BYTE KL_mods;

/*
KPN is number of bingins on a level (binding is a mapping from SC to KP to perform)
It should cover tilde,1..0,minus,plus,backslash,brackets,semicolon,apostrophe,comma,period,slash
and others alphanumericals: a key on left of Z and a key on right of apostrophe.
All of the tilde till slash happen to have SC less than 64.
*/
#define KPN 64
typedef LK KLV[KPN];
#define KLVN 6
typedef KLV KLY[KLVN];

KLY KL_kly;

bool KL_phys[255];

void KL_activate() {
    KL_active = true;
    SetWindowsHookEx(WH_KEYBOARD_LL, KL_proc, nil, 0);
}

void KL_disactivate() {
    KL_active = false;
    UnhookWindowsHookEx(KL_handle);
}

#define RawThisEvent() 0
#define StopThisEvent() 1
#define PassThisEvent() CallNextHookEx(NULL, aCode, wParam, lParam)
LRESULT CALLBACK KL_proc(int aCode, WPARAM wParam, LPARAM lParam) {
    if (aCode != HC_ACTION)
        return PassThisEvent();
    PKBDLLHOOKSTRUCT ev = (PKBDLLHOOKSTRUCT) lParam;
    DWORD flags = ev->flags;
    SC sc = (SC) ev->scanCode;
    //VK vk = (VK) ev->vkCode;
    bool down = (wParam != WM_KEYUP && wParam != WM_SYSKEYUP);
    // non-physical key events:
    //   injected key presses (generated by programs - keybd_event(), SendInput()),
    //   their (non-injected) release counterparts,
    //   fake shift presses and releases by driver accompanying numpad keys
    //     (so that numlock'ed keys are independent of shift state yet have the same 2 levels),
    //   LControl press/release by OS (the window system) triggered by AltGr RAlt event
    // Only check here for injected presses and corresponding releases.
    bool faked;
    faked = (flags & LLKHF_INJECTED || (!(KL_phys[sc]) && !down));
    if (flags & LLKHF_EXTENDED)
        sc |= 0x100;
    if (faked || sc >= KPN)
        return PassThisEvent();

    unsigned char lv = 0;
    if (KL_mods & KLM_L3)
        lv = 3;
    if (KL_mods & KLM_L5 && !lv)
        lv += 5;
    if (KL_mods & MOD_SHIFT)
        lv++;
    LK lk = KL_kly[lv][sc];
    if (!lk.active)
        return PassThisEvent();

    unsigned char mods = lk.mods;
    if (mods == KLM_WCHAR) {
        INPUT inp;
        inp.type = INPUT_KEYBOARD;
        inp.ki.wVk = 0;
        inp.ki.dwFlags = KEYEVENTF_UNICODE;
        inp.ki.dwExtraInfo = 0;
        inp.ki.wScan = sc;
        inp.ki.time = GetTickCount();
        SendInput(1, &inp, sizeof(INPUT));
    } else {
        keybd_event(lk.binding, sc, 0, 0);
    }

    return StopThisEvent();
}
#undef RawThisEvent
#undef StopThisEvent
#undef PassThisEvent

void KL_init() {
    ZeroMemory(KL_kly, sizeof(KL_kly));
    ZeroMemory(KL_phys, sizeof(KL_phys));
}

void KL_bind(SC sc, UINT mods, SC binding) {
    LK lk;
    int lv = 0;
    SC binding1 = binding;
    lk.active = true;
    lk.mods = mods | KLM_SC;
    if (mods & KLM_SC)
        binding1 = OS_sc_to_vk(binding, nil);
    lk.binding = binding1;
    KL_kly[lv][sc] = lk;
    if (mods & KLM_WCHAR) {
        printf("bind sc%03x[%d]: u%04x\n", sc, lv, binding);
    } else if (mods & KLM_SC) {
        printf("bind sc%03x[%d]: sc%03x=>vk%02x\n", sc, lv, binding, binding1);
    } else {
        printf("bind sc%03x[%d]: vk%02x\n", sc, lv, binding);
    }
}
